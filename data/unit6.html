<!DOCTYPE html>
<html>
<head>
	<title></title>
		<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta charset="utf-8">
		<style type="text/css">
		.carousel-inner img {
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body>
    <header>
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark"></nav>
        <a class="navbar-brand" href="#"><h1>Diploma CS Final Year Notes</h1></a><br><br>

      <nav class="navbar navbar-expand-lg navbar-dark bg-dark">

  <br>
<nav class="navbar navbar-expand-sm bg-dark navbar-dark">
  <!-- Brand -->
  <!-- Links -->
  <ul class="navbar-nav">
    <li class="nav-item active">
        <a class="nav-link" href="#">Home <span class="sr-only">(current)</span></a>
      </li>
     <li class="nav-item dropdown">
      <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
        Data Structure
      </a>
    </a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit7.html">Unit-7</a>


    </div>
  </li>
   <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Object Oriented
    </a>
     <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit7.html">Unit-7</a>

    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Unix
    </a>
     <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit7.html">Unit-7</a>

    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Software Engineere
    </a>
     <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\oft\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\soft\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\soft\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\soft\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\soft\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\soft\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\soft\unit7.html">Unit-7</a>
    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      .Net
    </a>
     <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit7.html">Unit-7</a>

    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Computer Network
    </a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\com/unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\com/unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\com/unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\com/unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\com/unit5.html">Unit-5</a>
    </div>
  </li>
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Data Mining
    </a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit7.html">Unit-7</a>

    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Cryptography
    </a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit7.html">Unit-7</a>

    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Java
    </a>
     <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\java\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\java\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\java\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\java\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\java\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\java\unit6.html">Unit-6</a>

    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
  PHP
    </a>
     <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\php\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\php\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\php\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\php\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\php\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\php\unit6.html">Unit-6</a>

      </div>
    </li>
  </ul>
</nav>
<br>
</header>
<p>
    <h1>Unit-6 Non Linear Data Structure:Graph</h1>
    <br>
 <!-- wp:paragraph -->
<p>6.1 Properties of Graphs&nbsp;<br>6.2 Representation of Graphs<br>6.2.1 Adjacency Matrix<br>6.2.2 Adjacency List&nbsp;<br>6.3 Traversal Algorithms- Depth First Search, Breadth First Search<br>6.4 Minimum Cost Spanning Tree&nbsp;<br>6.4.1 Prims Algorithm&nbsp;<br>6.4.2 Kruskal’s Algorithm&nbsp;<br>6.5 Shortest Path Algorithms<br>6.5.1 Dijkastra’s Algorithm&nbsp;<br>6.5.2 Bellman-Ford Algorithm<br>6.5.3 Warshal Algorithm<br>6.6 Applications of Graphs</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.1 Properties of graph:-</strong>graph एक non linear data structure होता है | इसका use कई application के लिए किया जाता है जैसे analysis of electrical circuit , finding shorted root , communication line , railway line etc graph G V तथा E होता है |&nbsp;<br>यहाँ पर V = VERTEXहै तथा E=EDGE है|</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":151} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/graph.jpg?w=459" alt="" class="wp-image-151"/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>TYPE OF GRAPH:-</h3>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>1.DIRECTED GRAPH:-</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>वह ग्राफ जिसमे EDGE की कोई दिशा होतीहै डायरेक्ट ग्राफ कहलाता है | और इस प्रकार के EDGE को DIRECTED EDGE कहते है || ग्राफ में edge को एक रेखा के through दर्शाया जाता है और यदि प्रत्येक रेखा में arrow का निशान बना हुआ होता है तो वह DIRECTED GRAPH कहलाता है |&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":152} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/directedgraph-2.jpg?w=251" alt="" class="wp-image-152"/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>2.UNDIRECTED GRAPH:-</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>वह ग्राफ जिसमे EDGE की कोई दिशा नहीं होतीहै| ग्राफ में edge को एक रेखा के through दर्शाया जाता है और यदि प्रत्येक रेखा में एरो का निशान नहीं बना हुआ होता है तो वह UNDIRECTED GRAPH कहलाता है |</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":153} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/undirectedgraph.jpg?w=1024" alt="" class="wp-image-153"/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>3.WEIGHTED GRAPH AND NON WEIGHTED GRAPH:-</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>कभी कभी graph में edges होतीहै | वे weight को carry करते है| ये weight वास्तविक नंबर होते है | directed और undirected graph दोनों ही weighted graph हो सकते है |</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":154} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/weighted-graph.png1_.png?w=297" alt="" class="wp-image-154"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>6.2 Representation of Graph:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>6.2.1 Adjacency Matrix:-</strong>इसमें graph को represent करने के लिए n*n की matrix बनाते है इस matrix में index की संख्या ० या १ होती है किन्ही दो vertex के मध्य edge होती है तो उसे १ से show करते है उसे 1 से show करते है|</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":156} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/adjacency_matrix_for_graph.png?w=466" alt="" class="wp-image-156"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>direct graph में adjacency matrix में अधिकांश element “0” होते है इस प्रकार की matrix को sparse matrix कहते है|</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>6.2.2 Adjacency List:-</strong>यह graph का linked list representation है इसमें graph के सभी vertex की एक list बना दी जाती है यह linked list में store vertex का order किसी भी प्रकार से important नहीं है</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":159} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/graph-representation-linked-representation2.png?w=495" alt="" class="wp-image-159"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Fig – direct graphके लिए list</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":160} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/graph-representation-linked-representation.png?w=497" alt="" class="wp-image-160"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Fig- undirected graphके लिए list</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>6.3 Traversal algorithm:Depth First Search, Breadth First Search:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>DEPTH FIRST SEARCH:-</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Depth First Search या traversal एक ऐसी technique है जिसमें हम possible graph में deep तक जाते हैं और nodes का पता लगाते है|यही है कि हम graph को एक node से दूसरे तक ले जाते हैं जब तक हम कर सकते हैं। एक बार जब हम एक node तक पहुँच जाते हैं, जहाँ हम और नीचे नहीं जा सकते, तो हम पीछे जाते हैं और एक node से पहले और इसी तरह आगे बढ़ते हैं।<br>backtracking कैसे काम करती है, यह समझने के लिए graph का depth-first traversal एक बहुत अच्छा उदाहरण है।<br>Let’s see how do we traverse a graph depth first.<br>1. Start with node u.<br>2. If u is already visited, return.<br>3. Mark visited[u] = true.<br>4. For all neighbors v of u.<br>5. v is now new u, so u=v and go back to step 2<br>6. When all neighbors are processed, backtrack to parent of current u<br>जब हम फिर से node S से शुरू करते हैं और S पर पता लगाने के लिए कोई edge नहीं है, तो यह traversal का end होगा।</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Algorithm:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 1:</strong>&nbsp;SET STATUS = 1 (ready state) for each node in G</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 2:</strong>&nbsp;Push the starting node A on the stack and set its STATUS = 2 (waiting state)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 3:</strong>&nbsp;Repeat Steps 4 and 5 until STACK is empty</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 4:</strong>&nbsp;Pop the top node N. Process it and set its STATUS = 3 (processed state)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 5:</strong>&nbsp;Push on the stack all the neighbours of N that are in the ready state (whose STATUS = 1) and set their<br>STATUS = 2 (waiting state)<br>[END OF LOOP]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 6:</strong>&nbsp;EXIT</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>EXAMPLE :</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Consider the graph G along with its adjacency list, given in the figure below. Calculate the order to print all the nodes of the graph starting from node H, by using depth first search (DFS) algorithm.</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://static.javatpoint.com/ds/images/depth-first-search-algorithm-example.png" alt="Depth First Search Algorithm"/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>SOLUTION :</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Push H onto the stack</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>STACK&nbsp;:&nbsp;H&nbsp;&nbsp;&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>POP the top element of the stack i.e. H, print it and push all the neighbours of H onto the stack that are is ready state.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>Print&nbsp;H&nbsp;&nbsp;&nbsp;</strong></li><li><strong>STACK&nbsp;:&nbsp;A&nbsp;&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Pop the top element of the stack i.e. A, print it and push all the neighbours of A onto the stack that are in ready state.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>Print&nbsp;A&nbsp;&nbsp;</strong></li><li><strong>Stack&nbsp;:&nbsp;B,&nbsp;D&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Pop the top element of the stack i.e. D, print it and push all the neighbours of D onto the stack that are in ready state.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>Print&nbsp;D&nbsp;&nbsp;&nbsp;</strong></li><li><strong>Stack&nbsp;:&nbsp;B,&nbsp;F&nbsp;&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Pop the top element of the stack i.e. F, print it and push all the neighbours of F onto the stack that are in ready state.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>Print&nbsp;F&nbsp;&nbsp;</strong></li><li><strong>Stack&nbsp;:&nbsp;B&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Pop the top of the stack i.e. B and push all the neighbours</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>Print&nbsp;B&nbsp;&nbsp;&nbsp;</strong></li><li><strong>Stack&nbsp;:&nbsp;C&nbsp;&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Pop the top of the stack i.e. C and push all the neighbours.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>Print&nbsp;C&nbsp;&nbsp;&nbsp;</strong></li><li><strong>Stack&nbsp;:&nbsp;E,&nbsp;G&nbsp;&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Pop the top of the stack i.e. G and push all its neighbours.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>Print&nbsp;G&nbsp;&nbsp;</strong></li><li><strong>Stack&nbsp;:&nbsp;E&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Pop the top of the stack i.e. E and push all its neighbours.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>Print&nbsp;E&nbsp;&nbsp;</strong></li><li><strong>Stack&nbsp;:&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Hence, the stack now becomes empty and all the nodes of the graph have been traversed.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The printing sequence of the graph will be :</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>H&nbsp;→&nbsp;A&nbsp;→&nbsp;D&nbsp;→&nbsp;F&nbsp;→&nbsp;B&nbsp;→&nbsp;C&nbsp;→&nbsp;G&nbsp;→&nbsp;E&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3>BREADTH FIRST SEARCH:-</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>BFS graph data structure&nbsp;को travers तथा search करने की एक अल्गोरिथम है.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>इसका प्रयोग ग्राफ में shortest path को ढूँढने तथा puzzle गेम्स को solve करने के लिए किया जाता है.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>डेटा स्ट्रक्चर में, BFS को implement करने के लिए&nbsp;<a href="https://ehindistudy.com/2015/11/17/what-is-queues-in-hindi/">queue</a>&nbsp;का प्रयोग किया जाता है.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>BFS में nodes को breadth wise (चौड़ाई से) visit किया जाता है.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>BFS में पहले किसी भी एक node को visit किया जाता है तथा उसके बाद उसके adjacent (नजदीक) के नोड्स को visit किया जाता है. इसके बाद इन adjacent नोड के भी सभी adjacent node को विजिट किया जाता है. और यह प्रक्रिया तब तक चलती है जब तक कि सभी nodes को विजिट नहीं कर लिया जाता है.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Breadth First Traversal: algorithm:-</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>Step 1:</strong>&nbsp;<strong>SET STATUS = 1 (ready state)<br>for each node in G</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 2:&nbsp;Enqueue the starting node A<br>and set its STATUS = 2<br>(waiting state)</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 3:&nbsp;Repeat Steps 4 and 5 until<br>QUEUE is empty</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 4:&nbsp;Dequeue a node N. Process it<br>and set its STATUS = 3<br>(processed state).</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 5:&nbsp;Enqueue all the neighbours of<br>N that are in the ready state<br>(whose STATUS = 1) and set<br>their STATUS = 2<br>(waiting state)<br>[END OF LOOP]</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 6:&nbsp;EXIT</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>EXAMPLE</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Consider the graph G shown in the following image, calculate the minimum path p from node A to node E. Given that each edge has a length of 1.</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://static.javatpoint.com/ds/images/breadth-first-search-algorithm-example.png" alt="Breadth First Search Algorithm"/></figure>
<!-- /wp:image -->

<!-- wp:heading -->
<h2>SOLUTION:</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Minimum Path P can be found by applying breadth first search algorithm that will begin at node A and will end at E. the algorithm uses two queues, namely&nbsp;<strong>QUEUE1</strong>&nbsp;and&nbsp;<strong>QUEUE2</strong>.&nbsp;<strong>QUEUE1</strong>&nbsp;holds all the nodes that are to be processed while&nbsp;<strong>QUEUE2</strong>&nbsp;holds all the nodes that are processed and deleted from&nbsp;<strong>QUEUE1</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Lets start examining the graph from Node A.</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>1. Add A to QUEUE1 and NULL to QUEUE2.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>QUEUE1&nbsp;=&nbsp;{A}&nbsp;&nbsp;</strong></li><li><strong>QUEUE2&nbsp;=&nbsp;{NULL}&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>2. Delete the Node A from QUEUE1 and insert all its neighbours. Insert Node A into QUEUE2</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>QUEUE1&nbsp;=&nbsp;{B,&nbsp;D}&nbsp;&nbsp;</strong></li><li><strong>QUEUE2&nbsp;=&nbsp;{A}&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>3. Delete the node B from QUEUE1 and insert all its neighbours. Insert node B into QUEUE2.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>QUEUE1&nbsp;=&nbsp;{D,&nbsp;C,&nbsp;F}&nbsp;&nbsp;&nbsp;</strong></li><li><strong>QUEUE2&nbsp;=&nbsp;{A,&nbsp;B}&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>4. Delete the node D from QUEUE1 and insert all its neighbours. Since F is the only neighbour of it which has been inserted, we will not insert it again. Insert node D into QUEUE2.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>QUEUE1&nbsp;=&nbsp;{C,&nbsp;F}&nbsp;&nbsp;</strong></li><li><strong>QUEUE2&nbsp;=&nbsp;{&nbsp;A,&nbsp;B,&nbsp;D}&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>5. Delete the node C from QUEUE1 and insert all its neighbours. Add node C to QUEUE2.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>QUEUE1&nbsp;=&nbsp;{F,&nbsp;E,&nbsp;G}&nbsp;&nbsp;</strong></li><li><strong>QUEUE2&nbsp;=&nbsp;{A,&nbsp;B,&nbsp;D,&nbsp;C}&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>6. Remove F from QUEUE1 and add all its neighbours. Since all of its neighbours has already been added, we will not add them again. Add node F to QUEUE2.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>QUEUE1&nbsp;=&nbsp;{E,&nbsp;G}&nbsp;&nbsp;</strong></li><li><strong>QUEUE2&nbsp;=&nbsp;{A,&nbsp;B,&nbsp;D,&nbsp;C,&nbsp;F}&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>7. Remove E from QUEUE1, all of E’s neighbours has already been added to QUEUE1 therefore we will not add them again. All the nodes are visited and the target node i.e. E is encountered into QUEUE2.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>QUEUE1&nbsp;=&nbsp;{G}&nbsp;&nbsp;</strong></li><li><strong>QUEUE2&nbsp;=&nbsp;{A,&nbsp;B,&nbsp;D,&nbsp;C,&nbsp;F,&nbsp;&nbsp;E}&nbsp;&nbsp;</strong></li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Now, backtrack from E to A, using the nodes available in QUEUE2.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The minimum path will be&nbsp;<strong>A → B → C → E</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>6.4 Minimum Cost Spanning Tree:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>What is a Spanning Tree?</strong>&nbsp;Given an undirected and connected graph G=(V,E), a spanning tree of the graph G is a tree that spans G (that is, it includes every vertex of G) and is a subgraph of G (every edge in the tree belongs to G)&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>What is Minimum Spaining Tree:-</strong>&nbsp;The cost of the spanning tree is the sum of the weights of all the edges in the tree. There can be many spanning trees. Minimum spanning tree is the spanning tree where the cost is minimum among all the spanning trees. There also can be many minimum spanning trees.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Minimum spanning tree has direct application in the design of networks. It is used in algorithms approximating the travelling salesman problem, multi-terminal minimum cut problem and minimum-cost weighted perfect matching. Other practical applications are:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>Cluster Analysis</strong></li><li><strong>Handwriting recognition</strong></li><li><strong>Image segmentation</strong></li></ol>
<!-- /wp:list -->

<!-- wp:image {"id":165} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/spaining-tree.jpg?w=780" alt="" class="wp-image-165"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Minimum Spanning Tree search के लिए दो famous algorithms हैं:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.4.1 Kruskal’s Algorithm:-</strong><br>-&gt; इस algorithm में related graph के सभी vertices को पहले बिना edge के रखा जाता है |<br>-&gt; प्रत्येक vertex को अलग-अलग tree माना जाता है|&nbsp;<br>-&gt; जुड़े हुए सभी pointers(node के साथ)=Null store रहता है|&nbsp;<br>-&gt; इस कारण यह greedy algorithm की श्रेणी में आती है |&nbsp;<br>-&gt; सभी tree को मिलकर एक forest बनाया जाता है| सभी vertex अलग-अलग रहते है उनमे कोई edge include नहीं रहता |&nbsp;<br>-&gt; प्रत्येक step में कम weight वाली edge को add करते है|&nbsp;<br>-&gt; इससे two tree आपस में जुड़ जाते है|<br>-&gt; प्रत्येक step में forest में से एक tree कम होता जाता है|<br>-&gt; यदि edge जोड़ते समय कोई cycle बनती है तो उस edge को जोड़ा नहीं जायेगा|</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Example of Kruskal’s Elgorithm:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":167} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/kruskal.jpg?w=780" alt="" class="wp-image-167"/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>ALGORITHM:-</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>1. Create a set with all edge in G<br>2. Initialize a priority Queue(Q) that contains all edge in(G) in ascending order of their weight.<br>3. Define a forest having n number of trees<br>4. while(Q!=Null)repeat<br>Edgen=Pop(Q)<br>if En is not creating a cycle and not<br>creating a loop then<br>add edge(En)to FOREST<br>else(create a cycle)<br>discard the edge(En)<br>end if<br>5.Return</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>6.4.2 Prim’s Algorithm:-</strong><br>-&gt; इस algorithm में किसी भी vertex से start करते हुए उसी के adjacent सबसे कम weight वाली edge को tree में add किया जाता है|<br>-&gt; यह algorithm भी greedy की category में आती है|&nbsp;<br>-&gt; जिस vertex से start किया जाता है उस vertex की adjacent vertex में से उस vertex को add किया जाता है जिसका weight कम हो|&nbsp;<br>-&gt; यह प्रक्रिया तब तक चलती है जब तक सारी vertex को connect नहीं जाता है|&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>ALGORITHM:-</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>1. Mark all vertices as not vertex<br>2. select any one edge/vertex as starting point<br>3. store all adjacent unvisited vertices(with weight)to priority Q<br>4. Now // add vertex(with smallest weight) tree<br>Vnew=Pop(Q)<br>5. mark Vnew as visited<br>6. Repeat step 3 to 5 until all vertices are not add to tree.<br>7.Return</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>EXAMPLE OF PRIM’S ALGORITHM:-</h3>
<!-- /wp:heading -->

<!-- wp:image {"id":168} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/prims.jpg?w=780" alt="" class="wp-image-168"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>6.5 Shortest path Algorithm:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>6.5.1 Dijkastra’s Algorithm :-</strong>Dijkastra’s algorithm is an algorithm for finding the shortest paths between nodes in a graph,which may represent,for example,road networks.<br>Graph में दिए गए source node के लिए, Algorithm उस node और next node के बीच सबसे छोटा path ढूंढता है। Destination node के लिए सबसे छोटा path निर्धारित हो जाने के बाद Algorithm को रोककर single node से single destination node तक के shortest path को find करने के लिए भी इसका उपयोग किया जा सकता है। उदाहरण के लिए, यदि graph के nodes cities का represent करते हैं और edge path एक सीधी सड़क से connect के pairs के बीच driving distance का represent करता है, तो एक शहर और अन्य सभी शहरों के बीच सबसे shortest path को find करने के लिए Dijkastra’s Algorithm का उपयोग किया जा सकता है।</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>DIJKSTRA’S ALGORITHM:</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Step 1: Remove all the loops (Any edge that starts and ends at the same vertex is loop)&nbsp;<br>Step 2: Remove all parallel edges between two vertices except the one with least weight.&nbsp;<br>Step 3: create the weight matrix table&nbsp;<br>(i) Set 0 to the source vertex and infinite to the remaining vertices.<br>For all vertices, repeat (ii) and (iii)&nbsp;<br>(ii) Mark the smallest unmarked value and mark that vertex.&nbsp;<br>(iii) Find those vertices which are directly connected with marked vertex and update all.<br>Update value formula:&nbsp;<br>New Destination value = minimum (Old Destination value, Marked value+ Edge Weight)&nbsp;<br>Step 4: Find the shortest path from source to destination using backtracking.&nbsp;<br>Put destination vertex in ‘shortest path’&nbsp;<br>(i) Set pointer to the last marked value and put that vertex to the ‘shortest path’ list.<br>(ii) Move the pointer up until marked value is change.&nbsp;<br>(iii) If the last marked value has been changed then move the pointer to the marked value in<br>that row and put that vertex to the ‘shortest path’ list.&nbsp;<br>Repeat (ii) to (iii) until the pointer will move to source vertex.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Example:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We step through Dijkstra’s algorithm on the graph used in the algorithm above:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><strong>Initialize distances according to the algorithm.</strong></li></ol>
<!-- /wp:list -->

<!-- wp:image {"id":170} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/dij1.png?w=750" alt="" class="wp-image-170"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Pick first node and calculate distances to adjacent nodes.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":171} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/dij2.png?w=728" alt="" class="wp-image-171"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Pick next node with minimal distance; repeat adjacent node distance calculations.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":172} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/dij3.png?w=752" alt="" class="wp-image-172"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Final result of shortest-path tree</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":173} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/dij4.png?w=766" alt="" class="wp-image-173"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>6.5.2 Bellman-Ford Algorithm:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Bellman Ford’s algorithm is used to find the shortest paths from the source vertex to all other vertices in a weighted graph. It depends on the following concept: Shortest path contains at most&nbsp;n−1&nbsp;edges, because the shortest path couldn’t have a cycle.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So why shortest path shouldn’t have a cycle ?<br>There is no need to pass a vertex again, because the shortest path to all other vertices could be found without the need for a second visit for any vertices.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Algorithm Steps:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><strong>The outer loop traverses from&nbsp;0&nbsp;:&nbsp;n−1.</strong></li><li><strong>Loop over all edges, check if the next node distance &gt; current node distance + edge weight, in this case update the next node distance to “current node distance + edge weight”.</strong></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>This algorithm depends on the relaxation principle where the shortest distance for all vertices is gradually replaced by more accurate values until eventually reaching the optimum solution. In the beginning all vertices have a distance of “Infinity”, but only the distance of the source vertex =&nbsp;0, then update all the connected vertices with the new distances (source vertex distance + edge weights), then apply the same concept for the new vertices with new distances and so on.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Example:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":174} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/bellman-ford-algorithm-1.png?w=1024" alt="" class="wp-image-174"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":175} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/bellman-ford-algorithm-2.png?w=1024" alt="" class="wp-image-175"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":176} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/bellman-ford-algorithm-3.png?w=1024" alt="" class="wp-image-176"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":177} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/bellman-ford-algorithm-4.png?w=1024" alt="" class="wp-image-177"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":179} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/bellman-ford-algorithm-5-1.png?w=1024" alt="" class="wp-image-179"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":180} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/bellman-ford-algorithm-6.png?w=1024" alt="" class="wp-image-180"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>6.6 Application of Graphs:-</strong>Graphs can be used to model many types of relations and processes in physical, biological,social and information systems. Many practical problems can be represented by graphs.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In computer science, graphs are used to represent networks of communication, data organization, computational devices.<br>Graph theory is also used to study molecules in chemistry and physics.<br>In mathematics, graphs are useful in geometry.<br>Weighted graphs, are used to represent structures in which pairwise connections have some numerical values. Ex: Road Network.<br>Graph algorithms are useful for calculating the shortest path in Routing .<br>Maps – finding the shortest/cheapest path for a car from one city to another, by using given roads.</p>
<!-- /wp:paragraph -->
<footer>
    <p class="text-center bg-dark text-white">@copyright Diploma CS Final Year</p>
  </footer>
      <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <!-- jQuery library -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <!-- Popper JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
  <!-- Latest compiled JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>
</html>