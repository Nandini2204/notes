<!DOCTYPE html>
<html>
<head>
	<title></title>
		<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta charset="utf-8">
		<style type="text/css">
		.carousel-inner img {
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body>
    <header>
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark"></nav>
        <a class="navbar-brand" href="#"><h1>Diploma CS Final Year Notes</h1></a><br><br>

      <nav class="navbar navbar-expand-lg navbar-dark bg-dark">

  <br>
<nav class="navbar navbar-expand-sm bg-dark navbar-dark">
  <!-- Brand -->
  <!-- Links -->
  <ul class="navbar-nav">
    <li class="nav-item active">
        <a class="nav-link" href="#">Home <span class="sr-only">(current)</span></a>
      </li>
     <li class="nav-item dropdown">
      <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
        Data Structure
      </a>
    </a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\data\unit7.html">Unit-7</a>


    </div>
  </li>
   <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Object Oriented
    </a>
     <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\c\unit7.html">Unit-7</a>

    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Unix
    </a>
     <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\unix\unit7.html">Unit-7</a>

    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Software Engineere
    </a>
     <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\oft\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\soft\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\soft\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\soft\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\soft\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\soft\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\soft\unit7.html">Unit-7</a>
    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      .Net
    </a>
     <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\net\unit7.html">Unit-7</a>

    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Computer Network
    </a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\com/unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\com/unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\com/unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\com/unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\com/unit5.html">Unit-5</a>
    </div>
  </li>
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Data Mining
    </a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\dm\unit7.html">Unit-7</a>

    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Cryptography
    </a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit6.html">Unit-6</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\cryp\unit7.html">Unit-7</a>

    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
      Java
    </a>
     <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\java\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\java\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\java\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\java\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\java\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\java\unit6.html">Unit-6</a>

    </div>
  </li> <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
  PHP
    </a>
     <div class="dropdown-menu">
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\php\unit1.html">Unit-1</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\php\unit2.html">Unit-2</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\php\unit3.html">Unit-3</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\php\unit4.html">Unit-4</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\php\unit5.html">Unit-5</a>
      <a class="dropdown-item" href="C:\Users\HP.LAPTOP-G09JCC50\Documents\web\php\unit6.html">Unit-6</a>

      </div>
    </li>
  </ul>
</nav>
<br>
</header>
<h1>Unit-6 Software Testing</h1><br>
<!-- wp:paragraph -->
<p>6.1 What is testing?&nbsp;<br>6.2 Verification v/s Validation<br>6.3 Design of Test Cases&nbsp;<br>6.4 Level of Testing&nbsp;<br>6.5 Unit Testing&nbsp;<br>6.6 Black Box Testing&nbsp;<br>6.6.1 Equivalence Class Partitioning&nbsp;<br>6.6.2 Boundary Value Analysis&nbsp;<br>6.7 White Box Testing&nbsp;<br>6.7.1 Statement, Branch coverage<br>6.7.2 Condition, Path coverage&nbsp;<br>6.7.3 McCabe`s Cyclomatic Complexity Metric<br>6.8 Integration Testing&nbsp;<br>6.9 System Testing&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.1 What is Testing?</strong>सॉफ्टवेयर टेस्टिंग-एक प्रक्रिया हैं, जिसके अंतर्गत सिस्टम या सिस्टम कंपोनेंट्स की जांच की जाती हैं। इस परिक्षण का मुख्य हेतु यह जांचना हैं की-सिस्टम कंपनी द्वारा निर्धारित मानकों (या कंपनी की जरूरतों के अनुसार) तैयार की गयी हो। आसान शब्दों में, अपने ग्राहकों को सॉफ्टवेर संबंधित जानकारी मुहैय्या कराने एवं उसकी गुणवत्ता परखने के लिए सॉफ्टवेर टेस्टिंग की जाती हैं। विक्रेता कंपनी द्वारा तयार सॉफ्टवेर को ग्राहक के जरूरतों के अनुसार विकसित किया जाता हैं और ग्राहक जिन परिस्थितियों में तयार सॉफ्टवेर का उपयोग करेगा, उस तरह की परिस्थितियों को लैब में तयार कर सॉफ्टवेर को परखा जाता है। सॉफ्टवेर टेस्टिंग का प्राथमिक उद्देश्य, सॉफ्टवेर फेलियर को ढूँढना हैं, अगर टेस्टिंग के दौरान सॉफ्टवेर फेल हो जाता हैं। तो जिन कारणों की वजह से सॉफ्टवेर फेल हुआ हैं, उन्हें ठीक किया जाता हैं। जिससे सॉफ्टवेर बिना किसी तकनिकी बाधा के सुचारू रूप से काम कर सकें।<br>डेवलपमेंट टीम द्वारा सॉफ्टवेर तयार किया जाता हैं, उसके बाद तयार सॉफ्टवेर को टेस्टिंग टीम के पास भेजा जाता हैं। टेस्टिंग करनेवाले व्यक्ती को सॉफ्टवेर टेस्टर्स कहा जाता हैं<br>सॉफ्टवेर टेस्टिंग के प्रकार (types of software testing) सॉफ्टवेर टेस्टिंग के मुख्य रूप से 3 प्रकार हैं-<br>ब्लैक बॉक्स टेस्टिंग (Black Box Testing)<br>वाइट बॉक्स टेस्टिंग (White Box Testing)<br>परफॉरमेंस टेस्टिंग (Performance Testing)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.2 Verification VS Validation Testing:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Software validation:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Validation यह जांचने की प्रकिया है की software user के requirement को पूरा करता है की नही | यह software development life cycle के अंत में किया जाता है | यदि software उन requirements से match करता है जिसके लिए यह बना है | तो यह validate है| Validation सुनिश्चित करता है की product development के तहत user के requirements के अनुसार है | Validation इस प्रश्न का उत्तर देता है की “ क्या हम उस उत्पाद को विकसित कर रहे है | जो users की सभी आवश्यकताओ को इस software से पूरा करने का attempts करता है | Validation user की आवश्यकताओं पर जोर देती है |</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Software verification:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>verification यह सुनिश्चित करने की प्रकिया है की क्या software business requirements को पूरा कर रहा है , और proper specification और तरीको ( methodologies) का पालन करने के लिए विकसित किया गया है | Verification इस प्रश्न का उत्तर देता है “ क्या हम सभी डिजाईन specifications(विनिर्देशो) का पालन करके इस product को विकसित कर रहे है | Verification ensure करता है की product design specification के अनुसार विकसित किया जा रहा है | Verification design और system specification पर केन्द्रित है</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table><tbody><tr><td>Verification</td><td>Validation</td></tr><tr><td>1. verification process में document, डिज़ाइन, कोड और प्रोग्राम की जाँच करना शामिल है|</td><td>1. यह real producgt के testing और validation का एक गतिशील तंत्र है|</td></tr><tr><td>2. इसमें कोड executing करना शामिल नहीं है|</td><td>2. इसमें हमेशा कोड executing करना शामिल होता है</td></tr><tr><td>3. verification में inspections, walkthroughs, reviews, और डेस्क- जाँच आदि जैसी methods का उपयोग किया जाता है।</td><td>3. यह ब्लैक बॉक्स testing, व्हाइट बॉक्स testing और non-functional testing जैसी विधियों का उपयोग करता है</td></tr><tr><td>4. क्या सॉफ्टवेयर specification के अनुरूप है या नहीं, इसकी जाँच की जाती है|</td><td>4. यह जांचता है कि सॉफ्टवेयर ग्राहक की आवश्यकताओं और अपेक्षाओं को पूरा करता है या नहीं</td></tr><tr><td>5. यह development cycle में bugs को जल्दी खोज लेता है</td><td>5. यह bug ढूंढ सकता है कि validation process पकड़ नहीं सकती है</td></tr><tr><td>6.target application और सॉफ्टवेयर architecture, specification, पूर्ण डिजाइन, high-level और डेटाबेस डिजाइन आदि है।</td><td>6. target एक real product है</td></tr><tr><td>7.क्यूए टीम verification करती है और सुनिश्चित करती है कि सॉफ्टवेयर SRS DOCUMENT में आवश्यकता के अनुसार हो।</td><td>7. testing टीम की भागीदारी के साथ सॉफ्टवेयर कोड पर validation execute किया जाता है।</td></tr><tr><td>8. यह velidation से पहले आता है</td><td>8. यह velidation के बाद आता है</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p><strong>6.3 Design of Test Case:-</strong>सॉफ्टवेयर testing process की गुणवत्ता में सुधार के लिए एक अच्छा testsing केस डिज़ाइन technique महत्वपूर्ण है। यह जारी किए गए सॉफ़्टवेयर की समग्र गुणवत्ता और प्रभावशीलता में सुधार करने में मदद करता है। रिलीज़ किए गए सॉफ़्टवेयर की उच्च-गुणवत्ता सुनिश्चित करने के लिए testing केस डिज़ाइन techinque निम्नलिखित हैं।<br>Test case design techniques:-<br>testing केस डिज़ाइन techniques का मुख्य उद्देश्य प्रभावी परीक्षण मामलों की मदद से सॉफ़्टवेयर की कार्यक्षमता और सुविधाओं का testing करना है। टेस्ट केस डिज़ाइन तकनीकों को मोटे तौर पर तीन प्रमुख श्रेणियों में वर्गीकृत किया गया है।<br>1. Specification-Based techniques<br>2. Structure-Based techniques<br>3. Experience-Based techniques</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>1. Specification-Based or Black-Box techniques:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>यह technique सॉफ़्टवेयर के बाहरी विवरण का लाभ उठाती है जैसे Technical specification, डिज़ाइन, और testing मामलों को डिज़ाइन करने के लिए क्लाइंट की आवश्यकताएं। technique testing को testing मामलों को develop करने में सक्षम बनाती है जो पूर्ण testing कवरेज प्रदान करते हैं। specification-based या ब्लैक बॉक्स टेस्ट केस डिज़ाइन techniques को 5 श्रेणियों में विभाजित किया गया है<br>Boundary Value Analysis (BVA)<br>Equivalence Partitioning (EP)<br>Decision Table Testing<br>State Transition Diagrams<br>Use Case Testing</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>2. Structure-Based or White-Box techniques:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>सॉफ्टवेयर की internal structure के आधार पर structure-based या white-box technique डिजाइन testing के मामले। यह technique development कोड का विस्तृत testing करती है। जिन डेवलपर्स को सॉफ्टवेयर कोड, इसकी internal structure और डिजाइन की पूरी जानकारी है, वे testing मामलों को डिजाइन करने में मदद करते हैं। इस technique को आगे पाँच श्रेणियों में विभाजित किया गया है।<br>Statement Testing &amp; Coverage&nbsp;<br>Decision Testing Coverage<br>Condition Testing<br>Multiple Condition Testing<br>All Path Testing</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Experience-Based techniques:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>ये technique सॉफ़्टवेयर के सबसे महत्वपूर्ण field को समझने के लिए tester के अनुभव पर अत्यधिक निर्भर हैं। इन techniques के result skill, knowledge और शामिल लोगों की विशेषज्ञता पर आधारित हैं। अनुभव आधारित तकनीकों के प्रकार इस प्रकार हैं:<br>Error Guessing<br>Exploratory Testing<br>Conclusion</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.4 Level of Testing:-</strong>सॉफ्टवेयर testinng का एक level एक ऐसी process है, जिसमें सॉफ्टवेयर / system की प्रत्येक इकाई या घटक का test किया जाता है। सिस्टम testing का मुख्य लक्ष्य निर्दिष्ट आवश्यकताओं के साथ सिस्टम के अनुपालन का मूल्यांकन करना है।<br>कई अलग-अलग testing level हैं जो सॉफ्टवेयर testing के लिए व्यवहार और प्रदर्शन की जांच करने में मदद करते हैं। इन testing levels को लापता क्षेत्रों और development life cycle state के बीच सामंजस्य स्थापित करने के लिए डिज़ाइन किया गया है। SDLC मॉडल में आवश्यकता पड़ने, specification, डिजाइन, कोडिंग या executing, परीक्षण और तैनाती जैसे चरणों की विशेषता होती है।<br>ये सभी चरण सॉफ्टवेयर testing level की process से गुजरते हैं। मुख्य रूप से चार परीक्षण स्तर हैं:<br>Unit Testing<br>Integration Testing<br>System Testing<br>Acceptance Testing</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Unit testing:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>एक यूनिट सिस्टम या एप्लिकेशन का सबसे छोटा test able part है जिसे compiled, liked, लोड और executed किया जा सकता है। इस तरह का testing प्रत्येक मॉड्यूल को अलग से testing करने में मदद करता है। इसका उद्देश्य सॉफ्टवेयर के प्रत्येक भाग को अलग करके testing करना है। यह जांचता है कि घटक कार्यक्षमताओं को पूरा कर रहा है या नहीं। इस तरह की टेस्टिंग डेवलपर्स द्वारा की जाती है।</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Integration testing:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Integration का अर्थ है combining। उदाहरण के लिए, इस testing phase में, विभिन्न सॉफ्टवेयर मॉड्यूल को एक समूह के रूप में संयोजित किया जाता है और यह सुनिश्चित करने के लिए test किया जाता है कि सिस्टम testing के लिए एकीकृत प्रणाली तैयार है। इंटीग्रेटिंग टेस्टिंग एक मॉड्यूल से दूसरे मॉड्यूल में डेटा प्रवाह की जाँच करता है। इस तरह का परीक्षण परीक्षकों द्वारा किया जाता है।</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>System testing:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>सिस्टम testing एक पूर्ण, एकीकृत प्रणाली पर किया जाता है। यह आवश्यकताओं के अनुसार सिस्टम के अनुपालन की जाँच करने की अनुमति देता है। यह component के समग्र संपर्क का परीक्षण करता है। इसमें लोड, performance, reliability और security testing शामिल है।<br>सिस्टम testing सबसे अधिक बार last testing करता है कि सिस्टम specification को पूरा करता है। यह testing के लिए functional और non-functional दोनों आवश्यकताओं का मूल्यांकन करता है।</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Acceptance testing:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Acceptance testing एक test है जो यह पता लगाने के लिए आयोजित किया जाता है कि क्या specification या contract की आवश्यकताओं को उसकी डिलीवरी के अनुसार पूरा किया गया है। acceptance testing मूल रूप से user या customer द्वारा किया जाता है। हालांकि, अन्य stockholder इस process में शामिल हो सकते हैं।</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.5 Unit testing:-</strong>यूनिट टेस्टिंग सॉफ्टवेर टेस्टिंग की एक विधि है जिसमें सॉफ्टवेर एप्लीकेशन के सबसे छोटे भाग (जिन्हें हम units कहते है) को test किया जाता है.| आसान शब्दों में कहें तो, “unit testing एक ऐसी टेस्टिंग है जिसमें प्रोग्राम को टुकड़ों में तोड़ लिया जाता है, तथा प्रत्येक टुकड़े को बारीकी से test किया जाता है.”| इस टेस्टिंग का मुख्य उद्देश्य यह सुनश्चित करना है कि सॉफ्टवेर का प्रत्येक यूनिट का source कोड सही है तथा इसे use किया जा सकता है.| पहले adhoc tools का प्रयोग units को test करने के लिए किया जाता था परन्तु आजकल unit test करने के लिए frameworks(जावा फ्रेमवर्क, .net फ्रेमवर्क तथा PHP फ्रेमवर्क आदि) का प्रयोग किया जाता है.| यूनिट टेस्ट developers के द्वारा लिखे तथा परफॉर्म किये जाते है तथा इसे करने के लिए WHITE BOX TESTING विधि का प्रयोग किया जाता है.| यहाँ याद रखने वाली बात यह है कि “यूनिट टेस्टिंग में बहुत ही अधिक समय लगता है तथा इसमें बहुत ही धैर्य की आवश्यकता होती है.”| यह टेस्टिंग बहुत ही अधिक प्रभावपूर्ण है क्यूंकि इसके प्रयोग के द्वारा अधिकतर defects को identify कर लिया जाता है.|</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":570} -->
<figure class="wp-block-image"><img src="https://d3e77fb4kspf54.cloudfront.net.cloudfront.net/wp-content/uploads/2020/07/unittesting.jpg" alt="" class="wp-image-570"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>सामन्यतया यूनिट टेस्टिंग integration टेस्टिंग के बाद की जाती है.|</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Advantage of unit testing</strong>:-</h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>यूनिट टेस्टिंग के निम्नलिखित लाभ है:-</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>1:-इस टेस्टिंग के द्वारा हम सॉफ्टवेर में defects तथा bugs को early stages में ही ढूँढ लेते है, बाद में defects तथा bugs को ढूँढना बहुत अधिक कठिन हो जाता है.|<br>2:-यह टेस्टिंग कोडिंग की प्रक्रिया को और अधिक effective तथा agile(फुर्तीला) बना देती है जिससे हम सॉफ्टवेर में ज्यादा से ज्यादा features को add कर सकते है.|<br>3:-जब हम यूनिट टेस्टिंग कर लेते है तो हमें manual टेस्टिंग की आवश्यकता बहुत कम रह जाती है. वैसे भी manual टेस्टिंग बहुत ही अधिक boring तथा खर्चीली है.|<br>4:-हम इस टेस्टिंग के द्वारा सॉफ्टवेर के design को बिना break किये हुए इसके डिज़ाइन को बेहतर बना सकते है.|<br>5:-जब हम पहले ही bugs को detect कर लेते है तो इससे हमारे समय तथा cost की बचत हो जाती है.|<br>6:-यह टेस्टिंग कोड की efficiency को बढाता है तथा इसको maintain करना आसान हो जाता है.|<br>7:-इस टेस्टिंग का एक फायदा यह है कि यह हमें सॉफ्टवेर के updated documentation(दस्तावेज) उपलब्ध करता है.|</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.6 Black Box Testing:-</strong>black box वह टेस्टिंग होती है जिसमें tester को सॉफ्टवेयर के अंदर के structure का ज्ञान होना जरुरी नही होता है तथा टेस्टर को coding की knowledge होना भी जरुरी नही होता है।&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":282} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/black-box-testing-in-hindi.jpg.jpeg?w=982" alt="" class="wp-image-282"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Black box टेस्टिंग एक ऐसी टेस्टिंग तकनीक है जिसमें परीक्षण के तहत सॉफ्टवेयर की कार्यछमता को टेस्ट किया जाता है जबकि सॉफ्टवेयर के internal कोड स्ट्रक्चर को नही देखा जाता है। Black box टेस्टिंग में सॉफ्टवेयर के सिर्फ इनपुट तथा आउटपुट पर ध्यान दिया जाता है। उदाहरण के लिए:- माना हमने whats app के सॉफ्टवेयर की black box टेस्टिंग करनी है तो हम उसके केवल इनपुट तथा आउटपुट पर ध्यान देते है जबकि हमें उसके internal structure की कोडिंग का ज्ञान नही होता है।</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.6.1 Equivalence Class Partitioning:-</strong>equivalence partitioning एक सॉफ्टवेर टेस्टिंग तकनीक है. इस तकनीक में सॉफ्टवेर यूनिट के इनपुट डेटा को equivalance classes (portitions) में विभाजित किया जाता है. equivalance classes का अर्थ है कि समान प्रकार का डेटा एक क्लास में विभाजित होगा और इस प्रकार अन्य समान डेटा समानता के आधार पर अलग-अलग classes में विभाजित होंगें.| इस तकनीक में हम प्रत्येक क्लास से केवल एक कंडीशन को ही टेस्ट करते है क्योंकि हमें पता होता है कि एक क्लास के सभी conditions एक जैसे ही होते हैं. अगर क्लास कि एक कंडीशन कार्य करती है तो उस क्लास की सभी conditions कार्य करेंगी. अगर क्लास कि एक टेस्ट condition कार्य नही करती है तो क्लास की कोई भी condition कार्य नही करेगी. equivalence partitioning तकनीक का फायदा यह है कि इससे सॉफ्टवेर को टेस्ट करने में समय कम लगता है.<br>इसे टेस्टिंग के सभी levels जैसे:- यूनिट टेस्टिंग, security testing, alpha beta testing आदि पर प्रयुक्त किया जा सकता है.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":283} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/equivalence.jpg?w=362" alt="" class="wp-image-283"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>equivalence partitioning को equivalence class partitioning भी कहते है|</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.6.2 Boundary Value Analysis:-</strong>boundary value analysis (BVA) एक ब्लैक बॉक्स टेस्टिंग तकनीक है जो कि class (partition) के मध्य की boundaries की टेस्टिंग पर आधारित होती है.| इसका प्रयोग इनपुट डेटा की boundaries में त्रुटियों को ढूंढने में किया जाता है.| boundary दो प्रकार की होती है एक lower boundary (जहाँ से सीमा(range) प्रारंभ होती है) और दूसरी (जहाँ सीमा समाप्त होती है). और प्रत्येक boundary की एक valid value तथा एक invalid value होती है.| test cases इन दोनों valid तथा invalid वैल्यूज के आधार पर डिज़ाइन किये जाते है तथा हम सामान्यतया प्रत्येक बाउंड्री से एक test case का चुनाव करते है.|<br>उदाहरण के लिये:- माना कि college में एक सॉफ्टवेर है जो कि valid user name तथा paasword पर ही work करता है तथा यह निम्नतम 6 तथा अधिकतम 10 करैक्टर ही accept करता है.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":284} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/boundary.png?w=409" alt="" class="wp-image-284"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>valid range 5-10, invalid range 5 या उससे कम, तथा invalid range 11 या 11 से ज्यादा.<br>image<br>BVA को range checking (रेंज चेकिंग) भी कहते है.|<br>Equivalence partitioning तथा boundary value analysis एक दुसरे के साथ जुड़े हुए है तथा ये टेस्टिंग के सभी levels पर एक साथ प्रयोग किये जाते है|</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.7 White Box Testing:-</strong>वह टेस्टिंग जिसमें टेस्टर को सॉफ्टवेयर के internal स्ट्रक्चर का ज्ञान होता है white box टेस्टिंग कहलाती है। इस प्रकार की टेस्टिंग सॉफ्टवेयर के अंदर की working पर आधारित होती है।&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":285} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/whitebox.jpg?w=728" alt="" class="wp-image-285"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>इस टेस्टिंग को white box इसलिए कहते है क्योंकि जो सॉफ्टवेयर होता है वह टेस्टर के लिए white box की तरह होता है जिसके अंदर वह देख सकता है। इस प्रकार की टेस्टिंग में टेस्टर को प्रोग्रामिंग का ज्ञान होता है। इस टेस्टिंग का बड़ा फायदा यह है कि हम सॉफ्टवेयर डेवलपमेंट के शुरुआत की stage में ही त्रुटियों का पता लगा सकते है। इस टेस्टिंग को open box testing , glass box testing तथा structural टेस्टिंग भी कहते है।</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.7.1 Statement , Branch coverage:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Branch Coverage:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Branch coverage एक testing method है, जिसका उद्देश्य यह सुनिश्चित करना है कि प्रत्येक निर्णय बिंदु से possible branch में से प्रत्येक को कम से कम एक बार execute किया जाए और इस तरह यह confirm किया जाए कि सभी reachable कोड execute हो। अर्थात्, प्रत्येक branch ने प्रत्येक रास्ता सही और गलत लिया। यह कोड की सभी branches को यह confirm करने में मदद करता है कि कोई भी शाखा आवेदन के असामान्य व्यवहार की ओर नहीं ले जाती है।&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Formula:-</strong>&nbsp;Branch Testing = (Number of decisions outcomes tested / Total Number of decision Outcomes) x 100 %<br><strong>Example:-</strong>&nbsp;Read A<br>Read B&nbsp;<br>IF A+B &gt; 10 THEN<br>Print “A+B is Large”<br>ENDIF&nbsp;<br>If A &gt; 5 THEN<br>Print “A Large”<br>ENDIF<br>The above logic can be represented by a flowchart as:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":287} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/branch_testing.jpg?w=472" alt="" class="wp-image-287"/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":1} -->
<h1><strong>Statement Coverage:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>स्टेटमेंट कवरेज एक whit बॉक्स testing design technique है जिसमें कम से कम एक बार source कोड में सभी executable statement का execution शामिल है। इसका उपयोग source कोड में बयानों की संख्या की गणना करने और मापने के लिए किया जाता है जिसे आवश्यकताओं को देखते हुए execute किया जा सकता है। स्टेटमेंट कवरेज का उपयोग testing के तहत कोड की संरचना के आधार पर परिदृश्य प्राप्त करने के लिए किया जाता है।</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Source Code:-</strong>&nbsp;Prints (int a, int b) { ———— Printsum is a function<br>int result = a+ b;&nbsp;<br>If (result&gt; 0)<br>Print (“Positive”, result)<br>Else<br>Print (“Negative”, result)<br>} ———– End of the source code&nbsp;<br>Scenario 1:<br>If A = 3, B = 9<br>The statements marked in yellow color are those which are executed as per the scenario<br>Number of executed statements = 5, Total number of statements = 7<br>Statement Coverage: 5/7 = 71%<br>Likewise we will see scenario 2,<br>Scenario 2:<br>If A = -3, B = -9<br>The statements marked in yellow color are those which are executed as per the scenario.<br>Number of executed statements = 6<br>Total number of statements = 7</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Statement Coverage: 6/7 = 85%</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.7.2 Condition , Path Coverage:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Condition coverage:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>condition कवरेज को प्रेडिकेटेट कवरेज के रूप में भी जाना जाता है जिसमें प्रत्येक बूलियन अभिव्यक्ति का मूल्यांकन TRUE और FALSE दोनों के लिए किया गया है।<br><strong>Example:-</strong>&nbsp;if ((A || B) &amp;&amp; C)<br>{<br>&lt;&lt; Few Statements &gt;&gt;<br>}<br>else<br>{<br>&lt;&lt; Few Statements &gt;&gt;<br>}<br>Result<br>उपरोक्त उदाहरण के लिए complete condition कवरेज criteria सुनिश्चित करने के लिए, A, B और C का मूल्यांकन कम से कम एक बार “true” और “false” के खिलाफ किया जाना चाहिए।<br>So, in our example, the 3 following tests would be sufficient for 100% Condition coverage testing.<br>A = true | B = not eval | C = false<br>A = false | B = true | C = true</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Path Coverage:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>base path testing समान है, लेकिन यह एक व्हाइट बॉक्स testing method पर आधारित है, जो flow या logical path के base पर testing के मामलों को परिभाषित करता है जिन्हें program के माध्यम से लिया जा सकता है। सॉफ्टवेयर इंजीनियरिंग में, बेसिस पथ testing में एक program में सभी संभावित ब्लॉकों का execution शामिल है और कम से कम testing मामलों के साथ अधिकतम path कवरेज प्राप्त करता है। यह branch testing और path testing method का एक संकर है।<br>सॉफ्टवेयर testing में base path के पीछे उद्देश्य यह है कि यह स्वतंत्र path की number को परिभाषित करता है, इस प्रकार आवश्यक testing मामलों की संख्या को स्पष्ट रूप से परिभाषित किया जा सकता है (प्रत्येक testing मामले की कवरेज को अधिकतम करता है)।<br>यहां हम एक सरल उदाहरण लेंगे, एक बेहतर विचार प्राप्त करने के लिए कि आधार path testing क्या है|</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":288} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/path.png?w=352" alt="" class="wp-image-288"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>उपर्युक्त उदाहरण में, हम देख सकते हैं कि कुछ सशर्त कथन हैं जो इस condition के आधार पर execute किए जाते हैं कि यह क्या पर्याप्त है। यहाँ 3 path या condition हैं जिन्हें आउटपुट प्राप्त करने के लिए testing करने की आवश्यकता है,<br>Path 1: 1,2,3,5,6, 7<br>Path 2: 1,2,4,5,6, 7<br>Path 3: 1, 6, 7</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>Steps for Basis Path testing:-</strong>&nbsp;The basic steps involved in basis path testing include<br>Draw a control graph (to determine different program paths)<br>Calculate Cyclomatic complexity (metrics to determine the number of independent paths)<br>Find a basis set of paths<br>Generate test cases to exercise each path<br><strong>Advantages of Basic Path Testing:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>&nbsp;1. यह अनावश्यक testing को कम करने में मदद करता है|<br>2. यह program logic पर ध्यान केंद्रित करता है |<br>3. सबसे कम मामले जो अभ्यास के आधार पर निर्धारित किए जाते हैं, कम से कम एक बार किसी program में प्रत्येक कथन को execute करेंगे|</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.7.3 McCabe`s Cyclomatic Complexity Metric:-</strong>McCabe की complexity को cyclomatic complexity कहते है। यह एक सॉफ्टवेयर metric है इस complexity का प्रयोग सॉफ्टवेयर प्रोग्राम की complexity को ज्ञात करने के लिए किया जाता है। Cyclomatic complexity प्रोग्राम के source कोड के द्वारा सीधे ही independent paths की संख्या को measure करती है। independent paths की संख्या जितनी अधिक होगी code उतना ही काम्प्लेक्स होगा। Independent paths वह path है जिसका कम से कम एक edge होता है तथा जिसका पहले traversal नही हुआ होता है। इस complexity को 1976 में Thomas McCabe ने प्रस्तावित किया था।<br>इसको गणितीय रूप में निम्नलिखित प्रकार से समझा जा सकता है:-<br>[McCabe’s complexity V(G) = E – N + 2]<br>जहां;<br>E= edges की संख्या<br>N=Vertices की संख्या<br>P=disconnected paths की संख्या है।</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>PROPERTIES OF MCCABE’S COMPLEXITY:-</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>इसके निम्नलिखित गुण होते है:-<br>1:- V (G ) &gt;= 1<br>2:-ग्राफ में V(G) independent path की अधिकतम संख्या है।<br>3:-यदि V(G)=1 तो ग्राफ में केवल एक path होगा।<br>4:-यह complexity को 10 से कम कर देता है।</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.8 Integration Testing:-</strong>integration testing सॉफ्टवेर टेस्टिंग की एक विधि है जिसमें दो या दो से अधिक सॉफ्टवेर units या modules को एक साथ combine किया जाता है तथा एक समूह में उनकी टेस्टिंग की जाती है. इस टेस्टिंग का मुख्य उद्देश्य integrated units के मध्य bugs तथा faults को खोजना है तथा units के मध्य कार्य, performance तथा विश्वसनीयता को identify करना है.| सामन्यतया intergation टेस्टिंग को एक integration टेस्टर के द्वारा perform किया जाता है.|<br>यह टेस्टिंग यूनिट टेस्टिंग के बाद तथा validation टेस्टिंग के पहले की जाती है. जब यूनिट टेस्टिंग कर ली जाती है तो प्रत्येक unit को एक-एक करके integrate किया जाता है और यह क्रिया तब तक चलती है जब तक कि सारें units को integrate नही कर लिया जाएँ.|</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>integration testing approach:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>integration टेस्टिंग की बहुत सी approaches है उनमें से कुछ निम्नलिखित है:-<br>1:-Top-down approach<br>2:-Bottom-up approach<br>3:-Big bang approach<br>1:-Top-down:-इस integration टेस्टिंग में top level के integrated units को सबसे पहले test किया जाता है तथा उसके बाद उसके निचे वाले sub-units को test किया जाता है.|&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":289} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/top-down-vs-bottom-up.jpg?w=600" alt="" class="wp-image-289"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>2:-Bottom-up:-इस integration टेस्टिंग में सबसे पहले bottom level के sub-units को test किया जाता है तथा उसके बाद ऊपर के मुख्य units को test किया जाता है|&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>3:-Big bang:-इस प्रकार की टेस्टिंग में सभी units को एक साथ integrate कर लिया जाता है तथा इसके बाद एक समूह में सभी को test कर लिया जाता है.|&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":290} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/big-bang-approach.png?w=500" alt="" class="wp-image-290"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>इस integration टेस्टिंग में किसी एक यूनिट को तब तक integrate नही किया जा सकता है जब तक कि सभी units तैयार ना हों.|</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>6.9 System Testing:-</strong>सिस्टम testing एक पूर्ण और पूरी तरह से integrated सॉफ्टवेयर product का testing है। आमतौर पर, सॉफ्टवेयर एक बड़े कंप्यूटर-आधारित सिस्टम का केवल एक तत्व है। अंततः, सॉफ्टवेयर अन्य सॉफ्टवेयर / हार्डवेयर सिस्टम के साथ हस्तक्षेप करता है। सिस्टम testing वास्तव में विभिन्न testing की एक श्रृंखला है जिसका एकमात्र उद्देश्य पूर्ण कंप्यूटर-आधारित system का उपयोग करना है।<br>System Testing involves testing the software code for following 1.बाहरी बाह्य उपकरणों सहित पूरी तरह से integrated application का testing करने के लिए कि कैसे component एक दूसरे के साथ और पूरे सिस्टम के साथ बातचीत करते हैं। इसे एंड टू एंड टेस्टिंग scenario भी कहा जाता है।<br>desired आउटपुट के लिए जाँच करने के लिए आवेदन में हर इनपुट की पूरी तरह से जाँच करें। 2.एप्लिकेशन के साथ user के अनुभव का परीक्षण।<br>3.यह system testing में शामिल है का एक बहुत ही बुनियादी description है। आपको specification testing मामलों का निर्माण करने और उन सुइट्स का test करने की आवश्यकता है जो आवेदन के प्रत्येक पहलू का testing करते हैं जैसा कि वास्तविक source कोड को देखे बिना बाहर से देखा गया है।</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><br><strong>Software Testing Hierarchy:-</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":291} -->
<figure class="wp-block-image"><img src="https://dcsfinalyearnotes.files.wordpress.com/2020/08/testing.jpg?w=241" alt="" class="wp-image-291"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>लगभग किसी भी सॉफ्टवेयर इंजीनियरिंग प्रक्रिया के साथ, सॉफ्टवेयर testing का एक निर्धारित क्रम होता है जिसमें चीजें होनी चाहिए। निम्नलिखित chronological order में व्यवस्थित सॉफ्टवेयर testing categories की एक list है। ये marketing की तैयारी में नए सॉफ्टवेयर का पूरी तरह से testing करने के लिए उठाए गए कदम हैं:</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Unit testing:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>एक यूनिट सिस्टम या एप्लिकेशन का सबसे छोटा test able part है जिसे compiled, liked, लोड और executed किया जा सकता है। इस तरह का testing प्रत्येक मॉड्यूल को अलग से testing करने में मदद करता है। इसका उद्देश्य सॉफ्टवेयर के प्रत्येक भाग को अलग करके testing करना है। यह जांचता है कि घटक कार्यक्षमताओं को पूरा कर रहा है या नहीं। इस तरह की टेस्टिंग डेवलपर्स द्वारा की जाती है।</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Integration testing:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Integration का अर्थ है combining। उदाहरण के लिए, इस testing phase में, विभिन्न सॉफ्टवेयर मॉड्यूल को एक समूह के रूप में संयोजित किया जाता है और यह सुनिश्चित करने के लिए test किया जाता है कि सिस्टम testing के लिए एकीकृत प्रणाली तैयार है। इंटीग्रेटिंग टेस्टिंग एक मॉड्यूल से दूसरे मॉड्यूल में डेटा प्रवाह की जाँच करता है। इस तरह का परीक्षण परीक्षकों द्वारा किया जाता है।</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>System testing:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>सिस्टम testing एक पूर्ण, एकीकृत प्रणाली पर किया जाता है। यह आवश्यकताओं के अनुसार सिस्टम के अनुपालन की जाँच करने की अनुमति देता है। यह component के समग्र संपर्क का परीक्षण करता है। इसमें लोड, performance, reliability और security testing शामिल है।<br>सिस्टम testing सबसे अधिक बार last testing करता है कि सिस्टम specification को पूरा करता है। यह testing के लिए functional और non-functional दोनों आवश्यकताओं का मूल्यांकन करता है।</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Acceptance testing:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Acceptance testing एक test है जो यह पता लगाने के लिए आयोजित किया जाता है कि क्या specification या contract की आवश्यकताओं को उसकी डिलीवरी के अनुसार पूरा किया गया है। acceptance testing मूल रूप से user या customer द्वारा किया जाता है। हालांकि, अन्य stockholder इस process में शामिल हो सकते हैं।</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1><strong>Different Types of System Testing:-</strong></h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>Usability Testing:-</strong>&nbsp;Usability testing मुख्य रूप से applicatiuon का उपयोग करने के लिए user की सहजता पर ध्यान केंद्रित करता है, नियंत्रण से निपटने में लचीलापन और सिस्टम के अपने उद्देश्यों को पूरा करने की क्षमता |&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Load Testing:-</strong>&nbsp;लोड टेस्टिंग यह जानना आवश्यक है कि एक सॉफ्टवेयर समाधान वास्तविक-जीवन भार के तहत प्रदर्शन करेगा।<br><strong>Regression Testing:-</strong>&nbsp;Regression Testing में यह सुनिश्चित करने के लिए किया गया testing शामिल है कि development process के दौरान किए गए परिवर्तनों में से कोई भी नए bugs का कारण नहीं है। यह यह भी सुनिश्चित करता है कि समय के साथ नए सॉफ्टवेयर मॉड्यूल के अलावा कोई भी पुराने bugs दिखाई न दें।<br><strong>Recovery Testing:-</strong>&nbsp;Recovery testing एक सॉफ़्टवेयर समाधान प्रदर्शित करने के लिए किया जाता है जो विश्वसनीय, विश्वसनीय है और संभावित क्रैश से सफलतापूर्वक पुनर्प्राप्त कर सकता है।<br><strong>Migration Testing:-</strong>&nbsp;माइग्रेशन testing यह सुनिश्चित करने के लिए किया जाता है कि सॉफ्टवेयर को पुराने सिस्टम इन्फ्रास्ट्रक्चर से मौजूदा सिस्टम इन्फ्रास्ट्रक्चर में बिना किसी समस्या के transfer किया जा सके।&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Functional Testing:-</strong>&nbsp;Functional पूर्णता testing के रूप में भी जाना जाता है, functional testing में किसी भी संभव लापता कार्यों के बारे में सोचना शामिल है। tester अतिरिक्त functionality की एक list बना सकते हैं जो कि किसी product को functional testing के दौरान उसे सुधारना पड़ सकता है।&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Hardware/Software Testing:-</strong>&nbsp;IBM का अर्थ है हार्डवेयर / सॉफ्टवेयर टेस्टिंग “HW / SW टेस्टिंग”। यह तब होता है जब tester सिस्टम testing के दौरान हार्डवेयर और सॉफ़्टवेयर के बीच बातचीत पर अपना ध्यान केंद्रित करता है।Advertisements</p>
<!-- /wp:paragraph -->
<br><br><br>
<footer>
  <p class="text-center bg-dark text-white">@copyright Diploma CS Final Year</p>
</footer>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
<!-- jQuery library -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<!-- Popper JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
<!-- Latest compiled JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>
</html>